
{
    
    
    
    
        
        
        
    
        
        
            
                
            
        
        
    
        
        
            
                
            
        
        
    
        
        
            
                
            
        
        
    
        
        
            
                
            
        
        
    
        
        
        
    
        
        
            
                
            
        
        
    
        
        
            
                
            
        
        
    
        
        
            
                
            
        
        
    
    "pages": [{"date":"2024-03-07","image":"","imageAlt":"","link":"http://localhost:1313/pages/aboutme/","summary":"\u003ch2 id=\"a-few-games-i-like\"\u003eA few games I like\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.wildfrostgame.com/\"\u003e\u003cem\u003e\u003cstrong\u003eWildfrost\u003c/strong\u003e\u003c/em\u003e\u003c/a\u003e is a cute and clever roguelike deckbuilder. There is so much going on during each turn, uncountable strategies, endlessly replayable! Very different (and in my humble opinion, more fun) than \u003cem\u003eSlay the Spire\u003c/em\u003e. Music, vibes, graphics and UX top notch. No meta-progression (as I like) (only unlocks for greater difficulty, which is not the same), so the (absurdly hard) final final boss can only get beaten the hard way, mastering the easy to grasp many mechanics.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://noitagame.com/\"\u003e\u003cem\u003e\u003cstrong\u003eNoita\u003c/strong\u003e\u003c/em\u003e\u003c/a\u003e is an unforgiving roguelike platformer. The wand crafting system is so deep, intriguing and intresting that it would be a great game with that alone. The world is big and sprinkled with many secrets. The enemies are varied and definitely not designed to help the player to beat them. 100-200 runs before a first win are to be expected as there is much to learn, but only to learn as there is no meta-progression (as I like) (only a few unlocks here and there). As healing and safety are rare, one shall know great fear and stress followed by intense relief (hopefully ^^).\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://subsetgames.com/itb.html\"\u003e\u003cem\u003e\u003cstrong\u003eInto the Breach\u003c/strong\u003e\u003c/em\u003e\u003c/a\u003e is a fair roguelike tactical puzzle game. Enemies let us know of their moves in advance so that every turn is like a puzzle to be solved. Multiple units to unlock and no meta-progression (or almost none, the pilot that we choose to follow us from run to run may count as some insignificant meta-progression). On the harder difficulties, every battle will feel like all hope is lost, and sometimes (often) all hopes are indeed lost (but mostly due to skill issues, for the game is fair and can be won consistently by some people (not me \u0026gt;_\u0026lt;)).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-few-games-i-like-but-they-have-meta-progression\"\u003eA few games I like but they have meta-progression\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.supergiantgames.com/games/hades/\"\u003e\u003cem\u003e\u003cstrong\u003eHades\u003c/strong\u003e\u003c/em\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://lastspell.com/\"\u003e\u003cem\u003e\u003cstrong\u003eThe Last Spell\u003c/strong\u003e\u003c/em\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dead-cells.com/\"\u003e\u003cem\u003e\u003cstrong\u003eDead Cells\u003c/strong\u003e\u003c/em\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNote that meta-progression is clever game design that guarantees that the player\u0026rsquo;s skill and the game\u0026rsquo;s difficulty eventually cross and make the game beatable. What bothers me on a personnal level is that I don\u0026rsquo;t want the game to get easier and easier, I want to learn and master the mechanics and win by skill and skill alone (and maybe a drop of luck) without doubting that I only won because I farmed the meta-progression enough to bring the difficulty down to my lowly skill.\u003c/p\u003e","tags":[],"text":"a few games i like wildfrost is a cute and clever roguelike deckbuilder. there is so much going on during each turn, uncountable strategies, endlessly replayable! very different (and in my humble opinion, more fun) than slay the spire. music, vibes, graphics and ux top notch. no meta-progression (as i like) (only unlocks for greater difficulty, which is not the same), so the (absurdly hard) final final boss can only get beaten the hard way, mastering the easy to grasp many mechanics. noita is an unforgiving roguelike platformer. the wand crafting system is so deep, intriguing and intresting that it would be a great game with that alone. the world is big and sprinkled with many secrets. the enemies are varied and definitely not designed to help the player to beat them. 100-200 runs before a first win are to be expected as there is much to learn, but only to learn as there is no meta-progression (as i like) (only a few unlocks here and there). as healing and safety are rare, one shall know great fear and stress followed by intense relief (hopefully ^^). into the breach is a fair roguelike tactical puzzle game. enemies let us know of their moves in advance so that every turn is like a puzzle to be solved. multiple units to unlock and no meta-progression (or almost none, the pilot that we choose to follow us from run to run may count as some insignificant meta-progression). on the harder difficulties, every battle will feel like all hope is lost, and sometimes (often) all hopes are indeed lost (but mostly due to skill issues, for the game is fair and can be won consistently by some people (not me \u0026gt;_\u0026lt;)). a few games i like but they have meta-progression hades the last spell dead cells note that meta-progression is clever game design that guarantees that the player\u0026rsquo;s skill and the game\u0026rsquo;s difficulty eventually cross and make the game beatable. what bothers me on a personnal level is that i don\u0026rsquo;t want the game to get easier and easier, i want to learn and master the mechanics and win by skill and skill alone (and maybe a drop of luck) without doubting that i only won because i farmed the meta-progression enough to bring the difficulty down to my lowly skill.\na few games that changed me minecraft is an infinite voxel world in which we can survive and thrive, explore and create. oh, the time i spent in these lands\u0026hellip; after playing so much of this game, i could not but dream of \u0026ldquo;making my own minecraft\u0026rdquo;, this is basically why i started to program. my past self was sad that it actually took more than a week after learning about loops and variables to be able to make a minecraft-like, but i am getting there now, and that dream never left me. minecraft carved itself in my life-scale ultimate goals by being so great. undertale is an rpg famous for its top-tier characters, story and music. the first game the story of which i felt greater than any game story before. i cried and laughed and cried again with and along the characters and the multiple story routes that the game offers. i have yet to find an other game that tells a more intense story, or a story that is telled via more instense manner. celeste is a try-hard plateformer of stunning graphics and music. difficult, then even more difficult, and then even more\u0026hellip; but it is worth the effort, to get to see madeline overcome her troubles up to the summit, granting feelings of accomplishment like nothing else ever could, leaving many lasting memories. :3 a few games i feel nostalgic about super mario galaxy new super mario bros. ","title":"About me"},{"date":"2024-03-06","image":"/qwy3-00.png","imageAlt":"","link":"http://localhost:1313/posts/qwy3/","summary":"Work in progress Minecraft-like, and also my Magnum Opus! Has infinite fast worldgen that uses some intersting principles that I explain here, along many other features.","tags":["Rust","Wgpu"],"text":"work in progress minecraft-like. this project intends to serve as a base to experiment with procedural generation a bit more than what is usually done in minecraft-likes. this page will only present what is already implemented and will not focus of the future of this project (for which i have so many ideas).\ngithub repository\nfeatures infinite world in all directions including up and down, thanks to cubic chunks. chunk meshing with covered face culling and ambiant occlusion trick. palette compression for chunk blocks (with palette indices being stored on as few bits as possible). multiple procedural terrain generators. some use a custom structure generation engine that is fast and can handle large structures while keeping the world independent from chunk loading order (see the generator structures-links-smooth). home made n-dimensional noise computation (more optimized than the noizebra implementation). optimized chunk loading order that culls away covered and inaccessible chunks and prioritizes terrain over air. blocks can be placed and removed. blocks can also be thrown. saving/loading to/from disk, named saves. aabb vs voxels simple but working collision resolution for the player and entities. entities that are simulated fast (all multithreaded!), rendered fast (instanced rendering, with per-instance texturing/coloring by indexing in a texture mapping and coloring table), saved/loaded/generated without loss or duplication. blocks being thrown are entities. there are also tiny rolling balls with eyes (that are generated by the world generation, even the structure generation can place entities). procedurally generated skybox texture. threadpool for terrain generation, meshing, entity physics(!), skybox texture generation. dynamic shadows by cascading shadow mapping. fog effect (blocks in the distance fading in the skybox). procedurally generated block textures (see the generator structures-generated-blocks). configurable controls for most controls. custom widget tree for the interface. grounds for a statically typed stripting language. configurable chunk size at launch time. (actually useful as this parameter influences the performance of the generation, gameloop and memory usage in complex ways and the best value that optimizes for what a given user prefers on a given machine may be different from one another, and it doesn\u0026rsquo;t cost anything to make this a parameter.) multiplayer (in a closed source repository). gallery a video: video of some qwy3 rolling ball animals in a world. also a video: video of some qwy3 block entities being thrown around a flat world. wip entities that are not blocks:\non interesting and fast terrain generation using noise there are multiple world generators available, most of which generate terrain by manipulating 2d and 3d noise.\nnice properties we want terrain that generates in a way that does not depend:\non the order in which the chunks generate, nor on the size of the chunks, nor on the offset of the chunk grid (the placing of the chunk edges). these constraints allow to consider that the world would always generate in the same way not matter the other settings or implementation details, instead of a generation that is influenced by the player\u0026rsquo;s actions. most people would not care about these properties but i want to see the worlds of qwy3 as exisiting independently from the player\u0026rsquo;s actions.\nusing transformed noise to generate each block of the world guarentees that the terrain generation has these properties because the generator can be expressed as a function that maps block coordinates to a block type. the generation of each block is independant from the generation of all the other blocks, no matter the size, position and loading order of the chunks.\nonly one step also why not wanting chunks to generate in only one step? some world generators of other voxel games (and also qwy2\u0026rsquo;s generation) would have each chunk generate in multiple steps, each step requiring the completion of the previous step for all the neighboring chunks. a problem with such technique is that we end up with a large number of partially generated chunks on the edge of the generated area which we cannot mesh and render to the player because their last generation step cannot be done because it would require to extend the generated area a chunk further and if we do that then we just moved this problem a chunk further. all these generation steps use precious time that is not spent on directly generating the chunks that end up visible to the player, and also use more memory.\nqwy3 generates each chunk in one step, meaning from nothing to block data to meshing without the need for neighboring chunks to even exist (although the meshing is done again when neighboring chunks are generated to make sure that the ambiant occlusion and face culling on the edges of the chunk take into account neighboring blocks from the neighboring chunks). this happens to not be a problem for structure generation, which is explained further below.\nwhat can we do with noise using n-dimensional noise and transforming it in original ways can make for interesting terrain that break the monotony of 2d height map style terrain. for starters, 3d noise allows for overhangs to appear which doesn\u0026rsquo;t happen with 2d height maps. it also allows for floating islands (which can be desirable or not depending on the feel we aim for the game). but it can allow for so much more!\nhere is an example of multiple 3d noises being used to generate curved lines in 3d, could be used as a base for the generation of some future aerial biomes (when biomes will be implemented):\nthis is a matter of discovering interesting ways to transform and combine noises and keeping the ones that happen to fit the desired feel of the game. some terrains like the lines above were not foud by chance but by an intuition about how to get line-like shapes to generate in 3d; however there is no reason to not try random noise manipulations as these sometimes turn out interesting enough.\nstructures transformed 3d noise is not enough! blocks are related to eachother only by proximity in the noise sampling. how to generate trees this way? it may be possible by carefully tweaking impossibly complex noise transformations for weeks or even months, but i would not resort to such cumbersome way.\nwe want to be able to describe structure generation as a sequential algorithm, using operations such as \u0026ldquo;place a block there\u0026rdquo;, \u0026ldquo;fill a sphere of such radius there\u0026rdquo;, etc.\nthe chunk edge problem but what to do when a tree decides to generate near the edge of a chunk and is cut by the edge?\na few solutions that were not applied:\nhaving multiple generation steps and structures smaller than a chunk is a simple solution, that was not applied to qwy3 because: a constraint on structure sizes that depend on the chunk size means that the world generation is indirectly influenced by the size of chunks, and as said above i refuse to let that parameter limit the generation, as also said above, having a single generation step for chunks is a great advantage that is not to be given up so easily. having the tree be generated anyway by the chunk in which it decided to appear, allowing the tree generation to place blocks outside of the chunk, editing chunks already generated and saving the blocks that are placed on non-generated chunks to be applied on them when they generate is also a solution. it was not applied to qwy3 because: it is harder to do it in a thread-safe way, as the generation of each chunk is done in a separate thread, it allows large structures but generating a large structure (that spans over many chunks) will require the edition of many chunks both for already-generated chunks and for to-be-generated chunks, all that for each chunk that generates a large structure, and if it allows large structures then a sufficiently large structure that is generated by a chunk far away from the player may generate blocks near or on the player; we want the generation to generate a chunk and be done with it, not comming back to already generated chunks to edit them potentially plenty of times. having structures smaller than a chunk and that are generated in a way that makes it so that they do not cross the chunk edges. this solution was not applied to qwy3 because: again, structure sizes shall not be limited by chunk sizes for reasons stated above, and the world generation shall not be influenced by the chunk grid offet (placing of the chunk edges). the chunk edge solution considering two adjacent chunks that must both generate different parts of the same tree, how can they agree on what to generate so that it matches perfectly at the shared edge that cuts the tree? how can they even know that they must agree on a shared tree?\nthe way noise-induced terrain works fine across chunk edges is because both chunks sample the same noise functions that happen to be spatially coherent. this coherency can be reproduced for structures. noise sampling is not limited to floating point parameters and can be done with integer parameters. this allows to map noise values to cells of a cubic lattice (that has a scale that does not depend on the size of chunks). chunks can now check which cells of the lattice they overlap with and use the noise values from these cells (that are shared with the other chuncks as per the fact that a noise function is deterministic (pure)) to generate parts of structures that occupy these cells. each chunk generates all the structures that might overlap with it and only keeps the parts that actually overlap with it; structures that might span over multiple chunks are \u0026ldquo;generated\u0026rdquo; multiple times, but always at the exact same position and in the exact same way (always seeded by the same noise values) so that all the parts overlaping different chunks match up perfectly.\nhere is an example of this technique being used to generate balls. as opposed to terrain generated by transforming some noise, here the noise is simply used to allow chunks to share values in cells of a lattice so that the chunks can agree on what structures can be generated (here, just balls at different positions in the cells of the lattice) so that said structures can cross chunk edges without issue. then noise transofmration can be used again to shape such structures to more natural-looking terrain. expanding on the idea the fact that the position and properties of all the stcuture is decided by noise values and queryable by their position means that a structure can be made aware of its neighboring structures and decide to generate accordingly. for example, the structures can link themselves by generating a bridge, both of the two linked structures generating its half of the bridge.\nhere is an example of the balls from earlier, all linked together in one direction: two structures can also decide to agree on some properties together, for example two structures can agree to link themselves or not (which is important if we want to generate structures that are not always linked together, if a pair does not agree on being linked or not then one might generate half a bridge and the other not and the bridge may stop awkwardly, which might look bad if such behavior was not intended). for two structures to agree on some properties, they can use noise again, as the (home made) noise used in qwy3 is n-dimensional it can be sampled in a 6d space at both the coordinates of the structures origins for example, in both order, and combine both noise values in an order-independant way (the mean of two values for example) to get a noise value associated to the pair of structures that they will both agree on (both structures will associate the same noise value to the other of their pair, for each pair).\nhere is the example of the balls again, but now they can be linked with all of their 6 direct lattice cell neighbors, they decide to link only sometimes, the bridges have a flat top and the generated shapes are also piped in some noise transofmration to make the bridges look more natural (as far as a lattice of bridges in an alien sky go anyway, the whole concept way not be very natural but if it was natural then it may look like this more than if it was not transformed using noise): one more strange-looking take on the idea: note: to compare these structure-using generators to the noise-using line generator mentioned above that generates lines of land in the sky, it appears that:\nthe structure-using one is harder to implement, but once implemented the structure-using generator is way easier to control and tweak to get it to generate what we want than the noise-using generator, and the structure-using generator expands what is actually possible, for example large lines with a circular cut is not really possible with the noise-using technique. more structures! until now was discussed a technique that allows for one structure per lattice cell that is not allowed to cross lattice cell edges. we want more structures and structures that can cross lattice cell edges.\nwhat is important is that a chunk that generates knows what structures might overlap with itself (the chunk) to generate them (and only them) so that any parts of these structures that overlap with itself (the chunk) are generated now (as we only allow ourselves this one and only occasion to generate all of the chunk\u0026rsquo;s content) or even to check weather a given structure will not overlap with itself (the chunk) to discard only what does not overlap.\nallowing multiple structures per lattice cells is as easy as deciding to do so. to allow for a variable number of structures per lattice cell, we can decide on the number of structures in one given lattice cell by getting a noise value n from the cell, and then for-looping to get new noise values to seed n structures and placing them in the cell.\nallowing lattice-cells-edges-crossing structures can be done as follows: we decide ahead-of-time on a size constraint for all the structures of the world. that gives a bounding box around a structure origin coordinates that is the only area in which that structure\u0026rsquo;s generation is allowed to place blocks. now, for a given chunk that generates, the chunk can list all the lattice cells that might generate structures that might overlap with itself (the chunk) by extending itself (the chunk) with margins as wide as the already known structure bounding box radius and that gives the area in which structure origins might generatate blocks that overlap with itself (the chunk we are generating). now, the chunk asks all these lattice cells for their structure origins, and can discard the ones that fall just ouside of the area in which structure origins might generate to overlap with itself (the chunk). all the remaining structure origins are to be generated, discarding every bit of generation that falls outside of the chunk we are generating.\nstructure generation can now be defined by a program that uses generation primitives like \u0026ldquo;placing a block there\u0026rdquo;, \u0026ldquo;placing a radius there\u0026rdquo;, etc. with these primitives handling the fact that if these shapes or blocks are placed outside of the chunk we are generating then they are discarded. the structure generation program can also querry the terrain with generation primitives such as \u0026ldquo;what is the terrain block there\u0026rdquo; (which simply makes the calculations done by the generation of the terrain for the whole chunk, but only for one block this time) to generate structures in a way that takes the terrain into account, this can be useful for example by structures that want to generate on the ground, as they first have to find the ground (because structure origins are generated uniformly in all the 3d space, and are not bound to generate from their origin coordinates but can actually use any part of their bounding box).\nhere are trees generated this way:\nthis may seem like a lot of work for each chunk, and each structure is generated plenty of times (as many times as there are chunks that it could have placed blocks in if it wanted). in practice, this happens to not be the bottleneck at all, if structure origins are not too densly generated and if structures keep their generation at least reasonably fast (in practice, it was a problem once and was fixed immediately without compromising on the look of the generated structures). after all, if chunks are 24x24x24 blocks then each chunk must generate the terrain on each of its blocks, that is 13824 blocks, each terrain block being generated by transforming some noise that takes time to be computed (and was optimized a bit but could be optimized way more with more effort in the future); the structures happen to not slow down the generation of each chunk so much that it was noticeable.\nthis way of placing and generating structures offers some parameters to tweak to achieve different results, like the lattice cell size, the range of number of structure origins per lattice cell, or the structure generation bounding box size.\nlarge bounding boxes allows for large structures (much larger that a chunk):\nseeding the structure origins with different structure types allows for, well, different structure types (dispatching the generation to the generation program that corresponds to the structure typed that was decided for each structure). here are trees and boulders, both using a different gereration program:\nthe bounding box is only about modifying the world, not about querrying information, there is no reason to limit the range in which the generation of a structure can access information. structures can still access the position of other structures, even other structures whose origins are outside of the bounding box of the structure we are generating. two structures whose bounding box touch eachother can decide to generate a bridge between them for example, in the same way as described further above:\nthat does it for structures.\nchunk culling and loading order loading a chunks means either generating its blocks or read them from the disk (the saving to/reading from the disk it not yet implemented), making the blocks of a chunk availavle in ram. this allows to interact with the blocks but also to mesh them to render them to the screen.\na setting of the game is the radius of a spherical area around the player in which the world is to be loaded and displayed. when the game is launched, the whole area is to be loaded as fast as possible, and when the player moves then unloaded chunks enter the sphere and creates an area (that can be large if the player moves fast) to generate. we often have to generate a large amount of chunks, and make it faster somehow. any compromise on the generator\u0026rsquo;s quality of work is out of the question, making the generator faster is somewhat discussed above and making reading from disk faster may be discussed after it is implemented in the future. what can we tweak ?\nloading and ignoring the right chunks to load, and loading the chunks in the right order, instead of naively loading chunks closer to the player until the whole spherical desired area is loaded. loading chunks in the right order makes for a faster meshing and rendering of the chunks that actually have a mesh to render and that the player will actually see, and ignoring chunks that the player has no chance to see or even to interact with allows to spend the constant amount of compute we have on the intresting chunks.\nnote: avoiding loading useless chunks also allows to have fewer chunks loaded for the same player experience, which cuts on memory usage and chunk management time in the gameloop.\nloading front (culling) the chunks containing and around the player are to be loaded, that we know for sure. how about working from there?\nlet us consider a set of chunks that we call the front. the front are the chunks that we actually consider for loading. the chunks containing and around the player are put in the front for starters. the chunks in the front that were not loaded yet are flagged for loading. once loaded, a chunk propagates the front to adjacent chunks that were not loaded yet, and removes itself from the front. that way, the front represents a surface of chunks that expands the loaded area (behind it) as it moves forward, eating the unloaded area.\nworking with a propagating front allows for the following optimization: making a chunk c not propagate the front to an adjacent chunk a if its face (the blocks on the face of c that touches a) is made of only opaque blocks. this makes the front fail to propagate through walls that happen to contain whole chunks faces, but also to fail to propagate underground or even inside large masses of solid blocks that lack holes. given a world that has a surface with only rock underground and air above, then the front will not penertate the underground area and only half of the spherical area will be loaded (thus in half the time!), and this generalizes to any ladmass configuration, no matter its shapes in 3d (given that the masses are large and lack holes).\nin a flat world, the loaded area only makes half the full spherical area:\nloading priorities (order) left at that, the above optimization would still make the loading spend most of its time loading huge volumes of air. air is fine, and must be loaded just in case it actually contains something worthy of notice (like blocks to be meshed that we failed to predict), and even if it turned out to be just air as predicted then having confirmed that it is air is also valuable information that is needed by gameplay (what if the player or an other entity (yet to be added) flies or falls through that air? having confirmed that it is indeed air allows for the flying or falling to happend quickly without having to hastily load these chunks). but if we suspect a non-loaded chunk to be air, the loading\u0026rsquo;s efforts may be better spent on an other chunk that we suspect to be part air and part blocks to be meshed. loading the likely-to-be air after the likely-to-be intresting chunks is a good idea.\nthat can be done by having two levels of priority in the front. the loaded chunks that propagate the front on adjacent chunks now also check for only-air-blocks faces, and put the corresponding adjacent chunks in the low priority font instead of putting them in the hight priority front for the others. a chunk containing the surface between the air and the undergorund (thus containing the ground) shall thus put the chunk above it in low priority if its top face is nothing but air, and this generalizes to any shape that takes the surface between solid blocks and air.\nstill in a flat world, the loaded area prioritizes the ground first:\nlow priority front chunks generate with a much lower probability than hight priority chunks (so as to have a chance to stumble early of land that was predicted as air). once there is no high priority front to load anymore, all the low priority front chunks are moved to the hight priority, so that one layer of air is now to load, and then the next, etc. as can be seen here:\n","title":"Qwy3 - WIP Minecraft-like in Rust \u0026 Wgpu"},{"date":"2024-03-06","image":"/qwy2-00.png","imageAlt":"","link":"http://localhost:1313/posts/qwy2/","summary":"\u003cp\u003eThe previous Minecraft-like attempt before \u003ca href=\"http://localhost:1313/posts/qwy3/\"\u003eQwy3\u003c/a\u003e.\u003c/p\u003e","tags":["C++","OpenGL"],"text":"the previous minecraft-like attempt before qwy3.\ngithub repository\nfeatures infinite world in all directions including up and down, thanks to cubic chunks. chunk meshing with covered face culling and ambiant occlusion trick. multiple procedural terrain generators. home made noise computation with up to 3 floating point dimensions and 1 integer dimpension. blocks can be placed and removed. saving/loading to/from named saves on disk. can save every generated chunks or only the ones that underwent change. threadpool for terrain generation (different steps in different tasks), loading from disk, initial meshing (but not remeshing). grounds for entities (some throwable spinning crystals as tests are implemented). dynamic shadows by shadow mapping (not cascading). fog effect (that only works because the sky is one uniform color instead of an arbitrary skybox). procedurally generated block textures (less intresting than qwy3\u0026rsquo;s). configurable controls for most controls. grounds for a stripting language. configurable chunk size at launch time. (actually useful as this parameter influences the performance of the generation, gameloop and memory usage in complex ways and the best value that optimizes for what a given user prefers on a given machine may be different from one another, and it doesn\u0026rsquo;t cost anything to make this a parameter.) custom build system for better control of the build process, with code generation for ressource embedding. gallery why the qwy3 rewrite? since learning rust (memory safe, no undefined behavior, super clean language features and type system, fearless concurrency (!), standard package manager, etc.) and hearing about wgpu (safe graphics api implemented in rust, wgsl (clean shader language), vulkan backend to use its validation layers), i thought more and more about the state of qwy2, stuck with old technologies (c++ and opengl, full of undefined behavior, legacy and inelegant features) and how much easier the development would have been if it was made in rust \u0026amp; wgpu since the beginning. in addition, i was unhappy with some technical decisions made for qwy2 (for example the fact that there are multiple generation steps for each chunks, making generation very slow), and a rewrite would allow to benefit from these mistakes to make it better.\nso far, i believe that the qwy3 rewrite in rust \u0026amp; wgpu was the best decision regarding this project. qwy2 shall remain in its unfinished state as the previous iteration of qwy3. third time\u0026rsquo;s a charm!\n","title":"Qwy2 - Previous Minecraft-like attempt in C++ \u0026 OpenGL"},{"date":"2024-03-06","image":"/noizebra-00.png","imageAlt":"","link":"http://localhost:1313/posts/noizebra/","summary":"\u003cp\u003eA prototype for the noise implementation of \u003ca href=\"http://localhost:1313/posts/qwy3/\"\u003eQwy3\u003c/a\u003e, and a collection of experiments with the noise to discover ways to manipulate it into intresting or desired shapes (\u003ca href=\"http://localhost:1313/posts/qwy3/\"\u003eQwy3\u003c/a\u003e also uses that experience).\u003c/p\u003e","tags":["Rust"],"text":"a prototype for the noise implementation of qwy3, and a collection of experiments with the noise to discover ways to manipulate it into intresting or desired shapes (qwy3 also uses that experience).\ngithub repository\nfeatures unoptimized prototype implementation of a value noise. octaves wrapper around the noise. the noise is n-dimensional, accepting any number of floating point and integer parameters. a collection of experiments on ways to manipulate and shape the noise into images, to serve as prototypes for procedural generation in qwy3. gallery ","title":"Noizebra - Handmade noise and experiments in Rust"},{"date":"2024-03-06","image":"/ipsys-saves-21.png","imageAlt":"","link":"http://localhost:1313/posts/ipsys/","summary":"\u003cp\u003eVisualizer of a particle system with randomized interaction laws that often happen to be quite mesmerizing to contemplate. Fast, colorful and somewhat intresting.\u003c/p\u003e","tags":["C","OpenGL"],"text":"visualizer of a particle system with randomized interaction laws that often happen to be quite mesmerizing to contemplate. fast, colorful and somewhat intresting.\ngithub repository\nfeatures particle system that runs on the gpu in a compute shader. different particle types, the number of which is decided at launch time. interaction laws for each oriented pair of particle types: the interaction laws depend on the distance between the interactee and the interacter particles. there are multiple laws for each oridented pair: a law that dictates attraction/repultion, a law that dictates rotation to the left/right, and a law that dictates acceleration/deceleration. interaction law randomizer, carefully tweaked to maximize \u0026ldquo;intresting\u0026rdquo; results occurences. randomized colors for each partcile type, color changing with speed and pressure (number of overlaping other particles). fading effect that leaves a tail behind particles saving/loading to/from disk laws, colors and state, written in a custom file format. grounds for a widget tree that is actually be maintainable in c. a few gifs gallery ","title":"IPSYS - Particle system with nice random laws in C \u0026 OpenGL"},{"date":"2024-03-06","image":"","imageAlt":"","link":"http://localhost:1313/posts/buildsystem/","summary":"\u003cp\u003eHandmade build system for C/C++ executable projects, made in Python.\u003c/p\u003e","tags":["C","C++","Python"],"text":"handmade build system for c/c++ executable projects, made in python.\nfeatures creating new source files warrant no modification of the build system. incremental compilation, keeps artifacts and recompile only the translation units that have changed. parses source files for #includes to make an inclusion graph and propagate changes in headers down the graph to flag all concerned translation units for recompilation correctly. the inclusion graph can be converted to a dot file. allows a special header to contain special custom declarations that trigger code generation to embed text/binary ressources in the binary. allows to run the compiled binary after compilation, but only if compilation worked. different compilation options produce artifacts that are stored separately so as to reproduce compilation profiles. easy to tweak to the needs of the project, that was the whole point of making a custom build system. why? why not just use cmake or make? the standard for c and c++ projects is to use cmake, or sometimes just make. some benefits are to be gained from such decision, for example some features such as parallel compilation, or the fact that some libraries include a bit of cmake script that is meant to ease its use as a dependency in cmake projects.\nin my humble opinion, these benefits do not outweight the inconvenience of how hard it is to understand the obscure ways by which these build systems are indended to be used and configured. if it is quite easy to get them to work on a project by copy-pasting the words of power from stackoverflow into our project, it often remains too mysterious (at least for me) to troubleshoot issues or tweak.\nin the end, the build system for a project is just a program that handles the efficient management of the compiling process. i understand that some domain specific language can make the writing and maintenance of such program easier by providing language features related to file and compilation handling. i do not think that being a domain specific language is an excuse to be so uncomfortable and hard to use as the dsls of cmake and make. using a more classic general purpose programming language such as python is so much nicer, with the small price of having to reimplement some features by hand.\nthe build system is an important detail of a c/c++ project; a detail, but an important one. i felt more confident in the future of these projects knowing that i fully understood the build system and could tweak/augment/fix it to make it fit to the needs of the project. using a proper language also allows to augment the build system with features such as code generation, that i believe even a master of cmake script would have a hard time to implement in such an impractical language.\nnote: this custom build system was used on personal hobby projects, where i thought it made sense. in a team of enough people, the fact that some solution is an industry standard makes it more relevant due to being known (to some extent) by all the team. i may find it intresting to design a custom writing system if there were no other humans to read it, but since there are other humans to communicate with then the standard writing system shared by everyone has more value.\nwhere is it used? there is no standalone version of this build system, it was copy-pasted in new projects and tweaked accordingly.\nhere it is used in qwy2 (c++ project), one can see the use of code generation triggered by the special declarations in this special header to embed some ressources in the binary. the other projects it was used in did not make it to this portfolio due to not being presentable enough due to being abandoned too soon.\nhere it is used in an abandoned c project that i happened to have posted on github, with the code generation for ressource embedding being triggered by this special header. ","title":"Custom Build System for C/C++ in Python"},{"date":"2024-03-06","image":"/pushdg-03.png","imageAlt":"","link":"http://localhost:1313/posts/pushdg/","summary":"Dungeon crawler on a procedurally generated square-tiled grid with turn-based sokoban-like mechanics.","tags":["Rust"],"text":"dungeon crawler on a procedurally generated square-tiled grid with turn-based sokoban-like mechanics. instead of winning by grinding and having high enough stats, what if we fight by carefully controlling the layout like we win in a sokoban-like puzzle game? push and pull objects on the grid, anticipate or even bait the enemies in a position in which you win, avoid getting cornered or blocked as the \u0026ldquo;redo\u0026quot;s (points spent to cancel actions) are limited and as precious as hp, if not more. death can be undone if there are enough reods left to get back in a non-losing position.\ngithub repository\nthe idea instead of having objects in an inventory and being decribed by a wall of stat numbers, here the objects are on the grid and must be pushed or pulled around in a sokoban-like fashion and the stats are replaced by the unique properties of objects.\nagents (the player, the enemies, anything that moves on its own) has a force (for now, 2) that allows them to push at most a equal mass in one move. a rock has a mass of 1 (like most objects), so the player may push at most 2 rocks in one move. the walls are too heavy to be pushed. the enemies and the player are also too heavy to be pushed, so instead of pushing eachother around they must hit each other to lower the other\u0026rsquo;s hp to 0. when pushing fails, objects in the attempted push chain try to interact with what they were pushed against and this may result in a hit if a target has hp and can take damages.\ncarefully organizing the layout of a battle to put the enemy in a losing position is the way to go in push dungeon. taking a few hits is fine (there are regen hearts to find), making a few mistakes is fine (it may cost redos, but there are also redo hearts to find), but making too many miskates without enough redos may lead to an unescapable position, which is how a puzzle game with limited redos is lost.\nfeatures procedural generation of messy dungeon-like maps which often happen to be intresting to play in. multiple objects with different mechanics (key to open doors, vision-blocking walls and pushable bush, see-through gem, shield that deals no damages, sword that deals more damages, pickaxe to break walls, rope that is pullable and can pull an other object, etc.). simple animations when objects move or are moved, damage number simple animations. enemies with a simple move heuristic which already provide intresting challenges when in great numbers and depending on the layout. gallery ","title":"Push Dungeon - Roguelike with sokoban-like mechanics in Rust"},{"date":"2024-03-06","image":"/sflk-00.png","imageAlt":"","link":"http://localhost:1313/posts/sflk/","summary":"\u003cp\u003eTrying their hand at \u0026ldquo;making their own programming language\u0026rdquo; is common place among programmers. My attempt at an interpreted language aimed at trying new things instead of focussing on speed, having fun instead of believing that my language would attract any intrest, there are hundreds of new languages each months after all.\u003c/p\u003e","tags":["Rust"],"text":"trying their hand at \u0026ldquo;making their own programming language\u0026rdquo; is common place among programmers. my attempt at an interpreted language aimed at trying new things instead of focussing on speed, having fun instead of believing that my language would attract any intrest, there are hundreds of new languages each months after all.\ngithub repository\nfeatures handmade tokenizer and parser. handmade implementation of big integers and arbitrarily precise fractions (!!), with unit tests. can be seen here. algebraic effects, which i only learned about after implementng them (they are called \u0026ldquo;signals\u0026rdquo; in sflk). all side effects executed by a scope can be intercepted by an outer scope with full control about what to do with it and how to respond. bytecode. visualizer of the ast and of the program execution (with scopes visible as gutter indentations). grounds for the pretty printing of remarks about the program. original design in some syntactical and semantical aspects of the language (most of which are for fun, to try something new regardless of usefulness or relevancy): no statement separator, ignored whitespace and two-letters keywords make for concise scripts. arbitrary number and order of \u0026ldquo;then\u0026rdquo; and \u0026ldquo;else\u0026rdquo; branches of if statements, same goes for some other clauses of other statements such as loop body and such. loop separator clause that runs inbetween iterations of the loop body. blocks of code are expressions, first-class values that can be executed in the current scope or in a sub-scope, they can be concatenated together or repeated, they replace functions. variable table of a scope can be copied, manipulated and poored in a scope, they replace hashmaps with identifier strings as keys. method-chain-like precedence for expressions involving binary operators. syntax error that disturb even the parser are \u0026ldquo;ignored\u0026rdquo; in that they are ebedded in the ast and as long as they are not executed then no error is raised. debugging tools in the intrepreted allow to still see these errors as it would be hard to debug otherwise. a readme explaning all the language quirks and features. why? for fun!\ngallery here can be seen the pretty printed ast of an sflk program, and the pretty printing of its execution with scope visualization:\nhere can be seen an sflk program containing a loop statement that has a separaror clause (sp keyword followed by a statement) which makes it trivial to print a separation between the prints of each iteration:\nhere can be seed an sflk program working with big integers, and then an sflk program working with arbitrarily precise fractions:\nhere can be seen tests of a pretty-printer of remarks on the program:\nhere can be seen an sflk program outputing an image in ppm format:\nhere can be seen an sflk program defining and then using a \u0026ldquo;signal interceptor\u0026rdquo; (which happens to really be just an effect handler actually):\n","title":"SFLK - Interpreted programming language implemented in Rust"},{"date":"2024-03-06","image":"/spine-02.png","imageAlt":"","link":"http://localhost:1313/posts/spine/","summary":"\u003cp\u003eCompiler of a stack-based simple language down to ELF executable with x86_64 machine code generated by handwritten code (no assembly), which works! First started in C, then a rewrite in Rust was started with better abstractions.\u003c/p\u003e","tags":["C","Rust","x86_64 machine code"],"text":"compiler of a stack-based simple language down to elf executable with x86_64 machine code generated by handwritten code (no assembly), which works! first started in c, then a rewrite in rust was started with better abstractions.\ngithub repository of the c version github repository of the rust attempt\nfeatures generates working elf executables with generated x86_64 machine code. elf headers generator. machine code generator for some x86_64 instructions, no assembly. data segment, code segment, labels with offsets corrected during final elf generation. simple stack-based language, c version only for now: one-character instructions with no whitespace separation required, for golfing purposes. control flow with ifs, loops, callbacks and named functions. classic stack manipulations instructions. support of two local valriables (only two for declaration with less characters for golfing) which can be \u0026ldquo;runtime-shadowed\u0026rdquo; or not in each function or callback. separated the call stack from the data stack (even though x86_64 only have one stack for both). pointer dereferecing read and write operations. syscall instruction, which provides lots of freedom. gallery here is a spine program (c implementation) that prints argc, all of argv and then all of envp (the environment variables), all of which is on the stack at the start of program execution on linux. n is a function that prints an integer in base 10, s prints a spine string (pointer and length, which are what is pushed by spine string literals), and z print null-terminated string (or c strings, which are how argv and envp are provided).\nhere are some spine named functions. n is different from the version above as it uses the local variables (h and v) to have a shorter code. s uses the fact that the write syscall takes the length of a string to do only one syscall. m allocates memory from the os via the mmap syscall (one of the intended uses of this syscall).\nwhy? for fun!\nthis took some learning about the x86_64 architecture, the x86_64 machine code representation of assembly instructions (which is known to be quite complex in some areas), the 64-bit elf executable format with its many fields and headers, how to work with machine code (not even assembly) and debug such matters.\n","title":"Spine - Compiled stack-based language implemented in C then Rust"}]
}

