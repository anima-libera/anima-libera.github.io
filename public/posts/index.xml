<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet href="/feed_style.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="https://www.rssboard.org/media-rss">
  <channel>
    <title>Posts on Anima&#39;s Portfolio</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on Anima&#39;s Portfolio</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Anima</copyright>
    <lastBuildDate>Wed, 06 Mar 2024 18:54:08 +0100</lastBuildDate><atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" /><icon>http://localhost:1313/favicon.svg</icon>
    
    
    <item>
      <title>Qwy3 - WIP Minecraft-like in Rust &amp; Wgpu</title>
      <link>http://localhost:1313/posts/qwy3/</link>
      <pubDate>Wed, 06 Mar 2024 18:54:08 +0100</pubDate>
      
      <guid>http://localhost:1313/posts/qwy3/</guid>
      <description><![CDATA[<p>Work in progress Minecraft-like. This project intends to serve as a base to experiment with procedural generation a bit more than what is usually done in Minecraft-likes. This page will only present what is already implemented and will not focus of the future of this project (for which I have so many ideas).</p>
<p><a href="https://github.com/anima-libera/qwy3">GitHub repository</a></p>
<h1 id="features">Features</h1>
<ul>
<li>Infinite world in all directions including up and down, thanks to cubic chunks.</li>
<li>Chunk meshing with covered face culling and ambiant occlusion trick.</li>
<li>Palette compression for chunk blocks (with palette indices being stored on as few bits as possible).</li>
<li>Multiple procedural terrain generators. Some use a custom structure generation engine that is fast and can handle large structures while keeping the world independent from chunk loading order (see the generator <code>structures-links-smooth</code>).</li>
<li>Home made N-dimensional noise computation (more optimized than the <a href="http://localhost:1313/posts/noizebra/">noizebra</a> implementation).</li>
<li>Optimized chunk loading order that culls away covered and inaccessible chunks and prioritizes terrain over air.</li>
<li>Blocks can be placed and removed.</li>
<li>Blocks can also be thrown.</li>
<li>Saving/loading to/from disk, named saves.</li>
<li>AABB vs voxels simple but working collision resolution for the player and entities.</li>
<li>Entities that are simulated fast (all multithreaded!), rendered fast (instanced rendering, with per-instance texturing/coloring by indexing in a texture mapping and coloring table), saved/loaded/generated without loss or duplication. Blocks being thrown are entities. There are also tiny rolling balls with eyes (that are generated by the world generation, even the structure generation can place entities).</li>
<li>Procedurally generated skybox texture.</li>
<li>Threadpool for terrain generation, meshing, <em>entity physics</em>(!), skybox texture generation.</li>
<li>Dynamic shadows by cascading shadow mapping.</li>
<li>Fog effect (blocks in the distance fading in the skybox).</li>
<li>Procedurally generated block textures (see the generator <code>structures-generated-blocks</code>).</li>
<li>Configurable controls for most controls.</li>
<li>Custom widget tree for the interface.</li>
<li>Grounds for a statically typed stripting language.</li>
<li>Configurable chunk size at launch time. (Actually useful as this parameter influences the performance of the generation, gameloop and memory usage in complex ways and the best value that optimizes for what a given user prefers on a given machine may be different from one another, and it doesn&rsquo;t cost anything to make this a parameter.)</li>
</ul>
<h1 id="gallery">Gallery</h1>
<p><img src="/qwy3-28.png" alt="Image of some Qwy3 world."></p>
<p>A video:
<video width=100% controls autoplay>
<source src="/qwy3-video-02.mp4" type="video/mp4">
Video of some Qwy3 rolling ball animals in a world.
</video></p>
<p><img src="/qwy3-17.png" alt="Image of some Qwy3 world.">
<img src="/qwy3-18.png" alt="Image of some Qwy3 world.">
<img src="/qwy3-19.png" alt="Image of some Qwy3 world."></p>
<p>Also a video:
<video width=100% controls autoplay>
<source src="/qwy3-video-01.mp4" type="video/mp4">
Video of some Qwy3 block entities being thrown around a flat world.
</video></p>
<p><img src="/qwy3-26.png" alt="Image of some Qwy3 world.">
<img src="/qwy3-20.png" alt="Image of some Qwy3 world.">
<img src="/qwy3-21.png" alt="Image of some Qwy3 world.">
<img src="/qwy3-22.png" alt="Image of some Qwy3 world.">
<img src="/qwy3-23.png" alt="Image of some Qwy3 world.">
<img src="/qwy3-24.png" alt="Image of some Qwy3 world.">
<img src="/qwy3-25.png" alt="Image of some Qwy3 world."></p>
<p>WIP entities that are not blocks:</p>
<p><img src="/qwy3-27.png" alt="Image of some Qwy3 world."></p>
<h1 id="on-interesting-and-fast-terrain-generation">On interesting and fast terrain generation</h1>
<h2 id="using-noise">Using noise</h2>
<p>There are multiple world generators available, most of which generate terrain by manipulating 2D and 3D noise.</p>
<p><img src="/qwy3-01.png" alt="Image of some terrain generation mainly based on noise."></p>
<h3 id="nice-properties">Nice properties</h3>
<p>We want terrain that generates in a way that does not depend:</p>
<ul>
<li>on the order in which the chunks generate,</li>
<li>nor on the size of the chunks,</li>
<li>nor on the offset of the chunk grid (the placing of the chunk edges).</li>
</ul>
<p>These constraints allow to consider that the world would always generate in the same way not matter the other settings or implementation details, instead of a generation that is influenced by the player&rsquo;s actions. Most people would not care about these properties but I want to see the worlds of Qwy3 as exisiting independently from the player&rsquo;s actions.</p>
<p>Using transformed noise to generate each block of the world guarentees that the terrain generation has these properties because the generator can be expressed as a function that maps block coordinates to a block type. The generation of each block is independant from the generation of all the other blocks, no matter the size, position and loading order of the chunks.</p>
<h3 id="only-one-step">Only one step</h3>
<p>Also why not wanting <em>chunks to generate in <strong>only one step</strong></em>? Some world generators of other voxel games (and also Qwy2&rsquo;s generation) would have each chunk generate in multiple steps, each step requiring the completion of the previous step for all the neighboring chunks. A problem with such technique is that we end up with a large number of partially generated chunks on the edge of the generated area which we cannot mesh and render to the player because their last generation step cannot be done because it would require to extend the generated area a chunk further and if we do that then we just moved this problem a chunk further. All these generation steps use precious time that is not spent on directly generating the chunks that end up visible to the player, and also use more memory.</p>
<p>Qwy3 generates each chunk in one step, meaning from nothing to block data to meshing without the need for neighboring chunks to even exist (although the meshing is done again when neighboring chunks are generated to make sure that the ambiant occlusion and face culling on the edges of the chunk take into account neighboring blocks from the neighboring chunks). This happens to not be a problem for structure generation, which is explained further below.</p>
<h3 id="what-can-we-do-with-noise">What can we do with noise</h3>
<p>Using N-dimensional noise and transforming it in original ways can make for interesting terrain that break the monotony of 2D height map style terrain. For starters, 3D noise allows for overhangs to appear which doesn&rsquo;t happen with 2D height maps. It also allows for floating islands (which can be desirable or not depending on the feel we aim for the game). But it can allow for so much more!</p>
<p>Here is an example of multiple 3D noises being used to generate curved lines in 3D, could be used as a base for the generation of some future aerial biomes (when biomes will be implemented):</p>
<p><img src="/qwy3-02.png" alt="Image of some terrain generation based on noise in an interesting way (I hope!)."></p>
<p>This is a matter of discovering interesting ways to transform and combine noises and keeping the ones that happen to fit the desired feel of the game. Some terrains like the lines above were not foud by chance but by an intuition about how to get line-like shapes to generate in 3D; however there is no reason to not try random noise manipulations as these sometimes turn out interesting enough.</p>
<p><img src="/qwy3-03.png" alt="Image of some terrain generation based on noise in a wierd way.">
<img src="/qwy3-04.png" alt="Image of some terrain generation based on noise in a way discovered by chance."></p>
<h2 id="structures">Structures</h2>
<p>Transformed 3D noise is not enough! Blocks are related to eachother only by proximity in the noise sampling. How to generate trees this way? It may be possible by carefully tweaking impossibly complex noise transformations for weeks or even months, but I would not resort to such cumbersome way.</p>
<p>We want to be able to describe structure generation as a sequential algorithm, using operations such as &ldquo;place a block there&rdquo;, &ldquo;fill a sphere of such radius there&rdquo;, etc.</p>
<h3 id="the-chunk-edge-problem">The chunk edge problem</h3>
<p>But what to do when a tree decides to generate near the edge of a chunk and is cut by the edge?</p>
<p>A few solutions that were <em>not</em> applied:</p>
<ul>
<li>Having multiple generation steps and structures smaller than a chunk is a simple solution, that was <em>not</em> applied to Qwy3 because:
<ul>
<li>a constraint on structure sizes that depend on the chunk size means that the world generation is indirectly influenced by the size of chunks, and as said above I refuse to let that parameter limit the generation,</li>
<li>as also said above, having a single generation step for chunks is a great advantage that is not to be given up so easily.</li>
</ul>
</li>
<li>Having the tree be generated anyway by the chunk in which it decided to appear, allowing the tree generation to place blocks outside of the chunk, editing chunks already generated and saving the blocks that are placed on non-generated chunks to be applied on them when they generate is also a solution. It was <em>not</em> applied to Qwy3 because:
<ul>
<li>it is harder to do it in a thread-safe way, as the generation of each chunk is done in a separate thread,</li>
<li>it allows large structures but generating a large structure (that spans over many chunks) will require the edition of many chunks both for already-generated chunks and for to-be-generated chunks, all that for each chunk that generates a large structure,</li>
<li>and if it allows large structures then a sufficiently large structure that is generated by a chunk far away from the player may generate blocks near or on the player; we want the generation to generate a chunk and be done with it, not comming back to already generated chunks to edit them potentially plenty of times.</li>
</ul>
</li>
<li>Having structures smaller than a chunk and that are generated in a way that makes it so that they do not cross the chunk edges. This solution was <em>not</em> applied to Qwy3 because:
<ul>
<li>again, structure sizes shall not be limited by chunk sizes for reasons stated above,</li>
<li>and the world generation shall not be influenced by the chunk grid offet (placing of the chunk edges).</li>
</ul>
</li>
</ul>
<h3 id="the-chunk-edge-solution">The chunk edge solution</h3>
<p>Considering two adjacent chunks that must both generate different parts of the same tree, how can they agree on what to generate so that it matches perfectly at the shared edge that cuts the tree? How can they even know that they must agree on a shared tree?</p>
<p>The way noise-induced terrain works fine across chunk edges is because both chunks sample the same noise functions that happen to be spatially coherent. This coherency can be reproduced for structures. Noise sampling is not limited to floating point parameters and can be done with integer parameters. This allows to map noise values to cells of a cubic lattice (that has a scale that does not depend on the size of chunks). Chunks can now check which cells of the lattice they overlap with and use the noise values from these cells (that are shared with the other chuncks as per the fact that a noise function is deterministic (pure)) to generate parts of structures that occupy these cells. Each chunk generates all the structures that might overlap with it and only keeps the parts that actually overlap with it; structures that might span over multiple chunks are &ldquo;generated&rdquo; multiple times, but always at the exact same position and in the exact same way (always seeded by the same noise values) so that all the parts overlaping different chunks match up perfectly.</p>
<p>Here is an example of this technique being used to generate balls. As opposed to terrain generated by transforming some noise, here the noise is simply used to allow chunks to share values in cells of a lattice so that the chunks can agree on what structures can be generated (here, just balls at different positions in the cells of the lattice) so that said structures can cross chunk edges without issue.
<img src="/qwy3-05.png" alt="Image of some terrain generation using a noise value lattice to generate balls."></p>
<p>Then noise transofmration can be used again to shape such structures to more natural-looking terrain.
<img src="/qwy3-06.png" alt="Image of some terrain generation using a noise value lattice to generate sky islands."></p>
<h3 id="expanding-on-the-idea">Expanding on the idea</h3>
<p>The fact that the position and properties of all the stcuture is decided by noise values and queryable by their position means that a structure can be made aware of its neighboring structures and decide to generate accordingly. For example, the structures can link themselves by generating a bridge, both of the two linked structures generating its half of the bridge.</p>
<p>Here is an example of the balls from earlier, all linked together in one direction:
<img src="/qwy3-07.png" alt="Image of some terrain generation using a noise value lattice to generate linked balls."></p>
<p>Two structures can also decide to agree on some properties together, for example two structures can agree to link themselves or not (which is important if we want to generate structures that are not always linked together, if a pair does not agree on being linked or not then one might generate half a bridge and the other not and the bridge may stop awkwardly, which might look bad if such behavior was not intended). For two structures to agree on some properties, they can use noise again, as the (home made) noise used in Qwy3 is N-dimensional it can be sampled in a 6D space at both the coordinates of the structures origins for example, in both order, and combine both noise values in an order-independant way (the mean of two values for example) to get a noise value associated to the pair of structures that they will both agree on (both structures will associate the same noise value to the other of their pair, for each pair).</p>
<p>Here is the example of the balls again, but now they can be linked with all of their 6 direct lattice cell neighbors, they decide to link only sometimes, the bridges have a flat top and the generated shapes are also piped in some noise transofmration to make the bridges look more natural (as far as a lattice of bridges in an alien sky go anyway, the whole concept way not be very natural but <em>if it was natural</em> then it may look like this more than if it was not transformed using noise):
<img src="/qwy3-08.png" alt="Image of some terrain generation using a noise value lattice to generate more links."></p>
<p>One more strange-looking take on the idea:
<img src="/qwy3-09.png" alt="Image of some terrain generation using a noise value lattice to generate even more links."></p>
<p><em>Note</em>: To compare these structure-using generators to the noise-using line generator mentioned above that generates lines of land in the sky, it appears that:</p>
<ul>
<li>the structure-using one is harder to implement,</li>
<li>but once implemented the structure-using generator is way easier to control and tweak to get it to generate what we want than the noise-using generator,</li>
<li>and the structure-using generator expands what is actually possible, for example large lines with a circular cut is not really possible with the noise-using technique.</li>
</ul>
<h3 id="more-structures">More structures!</h3>
<p>Until now was discussed a technique that allows for one structure per lattice cell that is not allowed to cross lattice cell edges. We want more structures and structures that can cross lattice cell edges.</p>
<p>What is important is that a chunk that generates knows what structures might overlap with itself (the chunk) to generate them (and only them) so that any parts of these structures that overlap with itself (the chunk) are generated now (as we only allow ourselves this one and only occasion to generate all of the chunk&rsquo;s content) or even to check weather a given structure will not overlap with itself (the chunk) to discard only what does not overlap.</p>
<p>Allowing multiple structures per lattice cells is as easy as deciding to do so. To allow for a variable number of structures per lattice cell, we can decide on the number of structures in one given lattice cell by getting a noise value N from the cell, and then for-looping to get new noise values to seed N structures and placing them in the cell.</p>
<p>Allowing lattice-cells-edges-crossing structures can be done as follows: We decide ahead-of-time on a size constraint for all the structures of the world. That gives a bounding box around a structure origin coordinates that is the only area in which that structure&rsquo;s generation is allowed to place blocks. Now, for a given chunk that generates, the chunk can list all the lattice cells that might generate structures that might overlap with itself (the chunk) by extending itself (the chunk) with margins as wide as the already known structure bounding box radius and that gives the area in which structure origins might generatate blocks that overlap with itself (the chunk we are generating). Now, the chunk asks all these lattice cells for their structure origins, and can discard the ones that fall just ouside of the area in which structure origins might generate to overlap with itself (the chunk). All the remaining structure origins are to be generated, discarding every bit of generation that falls outside of the chunk we are generating.</p>
<p>Structure generation can now be defined by a program that uses generation primitives like &ldquo;placing a block there&rdquo;, &ldquo;placing a radius there&rdquo;, etc. with these primitives handling the fact that if these shapes or blocks are placed outside of the chunk we are generating then they are discarded. The structure generation program can also querry the terrain with generation primitives such as &ldquo;what is the terrain block there&rdquo; (which simply makes the calculations done by the generation of the terrain for the whole chunk, but only for one block this time) to generate structures in a way that takes the terrain into account, this can be useful for example by structures that want to generate on the ground, as they first have to find the ground (because structure origins are generated uniformly in all the 3D space, and are not bound to generate from their origin coordinates but can actually use any part of their bounding box).</p>
<p>Here are trees generated this way:</p>
<p><img src="/qwy3-10.png" alt="Image of some terrain generation using the structure engine idea to generate trees."></p>
<p>This may seem like a lot of work for each chunk, and each structure is generated plenty of times (as many times as there are chunks that it could have placed blocks in if it wanted). In practice, this happens to not be the bottleneck at all, if structure origins are not too densly generated and if structures keep their generation at least reasonably fast (in practice, it was a problem once and was fixed immediately without compromising on the look of the generated structures). After all, if chunks are 24x24x24 blocks then each chunk must generate the terrain on each of its blocks, that is 13824 blocks, each terrain block being generated by transforming some noise that takes time to be computed (and was optimized a bit but could be optimized way more with more effort in the future); the structures happen to not slow down the generation of each chunk so much that it was noticeable.</p>
<p>This way of placing and generating structures offers some parameters to tweak to achieve different results, like the lattice cell size, the range of number of structure origins per lattice cell, or the structure generation bounding box size.</p>
<p>Large bounding boxes allows for large structures (much larger that a chunk):</p>
<p><img src="/qwy3-11.png" alt="Image of some terrain generation using the structure engine idea to generate large spikes."></p>
<p>Seeding the structure origins with different structure types allows for, well, different structure types (dispatching the generation to the generation program that corresponds to the structure typed that was decided for each structure). Here are trees and boulders, both using a different gereration program:</p>
<p><img src="/qwy3-12.png" alt="Image of some terrain generation using the structure engine with multiple structure types."></p>
<p>The bounding box is only about modifying the world, not about querrying information, there is no reason to limit the range in which the generation of a structure can access information. Structures can still access the position of other structures, even other structures whose origins are outside of the bounding box of the structure we are generating. Two structures whose bounding box touch eachother can decide to generate a bridge between them for example, in the same way as described further above:</p>
<p><img src="/qwy3-13.png" alt="Image of some terrain generation using the structure engine with multiple structure types."></p>
<p>That does it for structures.</p>
<h2 id="chunk-culling-and-loading-order">Chunk culling and loading order</h2>
<p>Loading a chunks means either generating its blocks or read them from the disk (the saving to/reading from the disk it not yet implemented), making the blocks of a chunk availavle in RAM. This allows to interact with the blocks but also to mesh them to render them to the screen.</p>
<p>A setting of the game is the radius of a spherical area around the player in which the world is to be loaded and displayed. When the game is launched, the whole area is to be loaded as fast as possible, and when the player moves then unloaded chunks enter the sphere and creates an area (that can be large if the player moves fast) to generate. We often have to generate a large amount of chunks, and make it faster somehow. Any compromise on the generator&rsquo;s quality of work is out of the question, making the generator faster is somewhat discussed above and making reading from disk faster may be discussed after it is implemented in the future. What can we tweak ?</p>
<p>Loading and ignoring the right chunks to load, and loading the chunks in the right order, instead of naively loading chunks closer to the player until the whole spherical desired area is loaded. Loading chunks in the right order makes for a faster meshing and rendering of the chunks that actually have a mesh to render and that the player will actually see, and ignoring chunks that the player has no chance to see or even to interact with allows to spend the constant amount of compute we have on the intresting chunks.</p>
<p><em>Note</em>: Avoiding loading useless chunks also allows to have fewer chunks loaded for the same player experience, which cuts on memory usage and chunk management time in the gameloop.</p>
<h3 id="loading-front-culling">Loading front (culling)</h3>
<p>The chunks containing and around the player are to be loaded, that we know for sure. How about working from there?</p>
<p>Let us consider a set of chunks that we call the <em>front</em>. The front are the chunks that we actually consider for loading. The chunks containing and around the player are put in the front for starters. The chunks in the front that were not loaded yet are flagged for loading. Once loaded, a chunk propagates the front to adjacent chunks that were not loaded yet, and removes itself from the front. That way, the front represents a surface of chunks that expands the loaded area (behind it) as it moves forward, eating the unloaded area.</p>
<p>Working with a propagating front allows for the following optimization: making a chunk C not propagate the front to an adjacent chunk A if its face (the blocks on the face of C that touches A) is made of only opaque blocks. This makes the front fail to propagate through walls that happen to contain whole chunks faces, but also to fail to propagate underground or even inside large masses of solid blocks that lack holes. Given a world that has a surface with only rock underground and air above, then the front will not penertate the underground area and only half of the spherical area will be loaded (thus in half the time!), and this generalizes to any ladmass configuration, no matter its shapes in 3D (given that the masses are large and lack holes).</p>
<p>In a flat world, the loaded area only makes half the full spherical area:</p>
<p><img src="/qwy3-14.png" alt="Image of the loaded area which did not load underground."></p>
<h3 id="loading-priorities-order">Loading priorities (order)</h3>
<p>Left at that, the above optimization would still make the loading spend most of its time loading huge volumes of air. Air is fine, and must be loaded just in case it actually contains something worthy of notice (like blocks to be meshed that we failed to predict), and even if it turned out to be just air as predicted then having confirmed that it is air is also valuable information that is needed by gameplay (what if the player or an other entity (yet to be added) flies or falls through that air? Having confirmed that it is indeed air allows for the flying or falling to happend quickly without having to hastily load these chunks). But if we suspect a non-loaded chunk to be air, the loading&rsquo;s efforts may be better spent on an other chunk that we suspect to be part air and part blocks to be meshed. Loading the likely-to-be air after the likely-to-be intresting chunks is a good idea.</p>
<p>That can be done by having two levels of priority in the front. The loaded chunks that propagate the front on adjacent chunks now also check for only-air-blocks faces, and put the corresponding adjacent chunks in the <em>low priority font</em> instead of putting them in the <em>hight priority front</em> for the others. A chunk containing the surface between the air and the undergorund (thus containing the ground) shall thus put the chunk above it in low priority if its top face is nothing but air, and this generalizes to any shape that takes the surface between solid blocks and air.</p>
<p>Still in a flat world, the loaded area prioritizes the ground first:</p>
<p><img src="/qwy3-15.png" alt="Image of the loaded area which did not load the air yet."></p>
<p>Low priority front chunks generate with a much lower probability than hight priority chunks (so as to have a chance to stumble early of land that was predicted as air). Once there is no high priority front to load anymore, all the low priority front chunks are moved to the hight priority, so that one layer of air is now to load, and then the next, etc. as can be seen here:</p>
<p><img src="/qwy3-16.png" alt="Image of the loaded area which loads the air in layers."></p>
]]></description>
      
        <media:thumbnail url="http://localhost:1313/qwy3-00.png" />
      
    </item>
    
    
    
    <item>
      <title>Qwy2 - Previous Minecraft-like attempt in C&#43;&#43; &amp; OpenGL</title>
      <link>http://localhost:1313/posts/qwy2/</link>
      <pubDate>Wed, 06 Mar 2024 18:53:08 +0100</pubDate>
      
      <guid>http://localhost:1313/posts/qwy2/</guid>
      <description><![CDATA[<p>The previous Minecraft-like attempt before <a href="http://localhost:1313/posts/qwy3/">Qwy3</a>.</p>
<p><a href="https://github.com/anima-libera/qwy2">GitHub repository</a></p>
<h1 id="features">Features</h1>
<ul>
<li>Infinite world in all directions including up and down, thanks to cubic chunks.</li>
<li>Chunk meshing with covered face culling and ambiant occlusion trick.</li>
<li>Multiple procedural terrain generators.</li>
<li>Home made noise computation with up to 3 floating point dimensions and 1 integer dimpension.</li>
<li>Blocks can be placed and removed.</li>
<li>Saving/loading to/from named saves on disk. Can save every generated chunks or only the ones that underwent change.</li>
<li>Threadpool for terrain generation (different steps in different tasks), loading from disk, initial meshing (but not remeshing).</li>
<li>Grounds for entities (some throwable spinning crystals as tests are implemented).</li>
<li>Dynamic shadows by shadow mapping (not cascading).</li>
<li>Fog effect (that only works because the sky is one uniform color instead of an arbitrary skybox).</li>
<li>Procedurally generated block textures (less intresting than Qwy3&rsquo;s).</li>
<li>Configurable controls for most controls.</li>
<li>Grounds for a stripting language.</li>
<li>Configurable chunk size at launch time. (Actually useful as this parameter influences the performance of the generation, gameloop and memory usage in complex ways and the best value that optimizes for what a given user prefers on a given machine may be different from one another, and it doesn&rsquo;t cost anything to make this a parameter.)</li>
<li><a href="http://localhost:1313/posts/buildsystem/">Custom build system</a> for better control of the build process, with code generation for ressource embedding.</li>
</ul>
<h1 id="gallery">Gallery</h1>
<p><img src="/qwy2-01.png" alt="Image of some Qwy2 world with the classic generator.">
<img src="/qwy2-02.png" alt="Image of some Qwy2 world with a sky lines biome near a solid biome.">
<img src="/qwy2-03.png" alt="Image of some Qwy2 world with two biomes near some empty sky.">
<img src="/qwy2-04.png" alt="Image of some Qwy2 world with multiple biomes.">
<img src="/qwy2-05.png" alt="Image of some Qwy2 flat-ish world with a handmade small amongus crewmate statue."></p>
<h1 id="why-the-qwy3-rewrite">Why the Qwy3 rewrite?</h1>
<p>Since learning <a href="https://www.rust-lang.org/">Rust</a> (memory safe, no undefined behavior, super clean language features and type system, <a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">fearless concurrency (!)</a>, standard package manager, etc.) and hearing about <a href="https://wgpu.rs/">Wgpu</a> (<em>safe graphics API</em> implemented in Rust, <a href="https://www.w3.org/TR/WGSL/">WGSL</a> (clean shader language), Vulkan backend to use its validation layers), I thought more and more about the state of Qwy2, stuck with old technologies (C++ and OpenGL, full of undefined behavior, legacy and inelegant features) and how much easier the development would have been if it was made in Rust &amp; Wgpu since the beginning. In addition, I was unhappy with some technical decisions made for Qwy2 (for example the fact that there are multiple generation steps for each chunks, making generation very slow), and a rewrite would allow to benefit from these mistakes to make it better.</p>
<p>So far, I believe that the <a href="http://localhost:1313/posts/qwy3/">Qwy3</a> rewrite in Rust &amp; Wgpu was the best decision regarding this project. Qwy2 shall remain in its unfinished state as the previous iteration of Qwy3. Third time&rsquo;s a charm!</p>
]]></description>
      
        <media:thumbnail url="http://localhost:1313/qwy2-00.png" />
      
    </item>
    
    
    
    <item>
      <title>Noizebra - Handmade noise and experiments in Rust</title>
      <link>http://localhost:1313/posts/noizebra/</link>
      <pubDate>Wed, 06 Mar 2024 18:52:08 +0100</pubDate>
      
      <guid>http://localhost:1313/posts/noizebra/</guid>
      <description><![CDATA[<p>A prototype for the noise implementation of <a href="http://localhost:1313/posts/qwy3/">Qwy3</a>, and a collection of experiments with the noise to discover ways to manipulate it into intresting or desired shapes (<a href="http://localhost:1313/posts/qwy3/">Qwy3</a> also uses that experience).</p>
<p><a href="https://github.com/anima-libera/noizebra">GitHub repository</a></p>
<h1 id="features">Features</h1>
<ul>
<li>Unoptimized prototype implementation of a <a href="https://en.wikipedia.org/wiki/Value_noise">value noise</a>.</li>
<li>Octaves wrapper around the noise.</li>
<li>The noise is N-dimensional, accepting any number of floating point and integer parameters.</li>
<li>A collection of experiments on ways to manipulate and shape the noise into images, to serve as prototypes for procedural generation in <a href="http://localhost:1313/posts/qwy3/">Qwy3</a>.</li>
</ul>
<h1 id="gallery">Gallery</h1>
<p><img src="/noizebra-01.png" alt="Image of a Noizebra output.">
<img src="/noizebra-02.png" alt="Image of a Noizebra output.">
<img src="/noizebra-03.png" alt="Image of a Noizebra output.">
<img src="/noizebra-04.png" alt="Image of a Noizebra output.">
<img src="/noizebra-05.png" alt="Image of a Noizebra output.">
<img src="/noizebra-06.png" alt="Image of a Noizebra output.">
<img src="/noizebra-07.png" alt="Image of a Noizebra output.">
<img src="/noizebra-08.png" alt="Image of a Noizebra output.">
<img src="/noizebra-09.png" alt="Image of a Noizebra output.">
<img src="/noizebra-10.png" alt="Image of a Noizebra output.">
<img src="/noizebra-11.png" alt="Image of a Noizebra output.">
<img src="/noizebra-12.png" alt="Image of a Noizebra output.">
<img src="/noizebra-13.png" alt="Image of a Noizebra output.">
<img src="/noizebra-14.png" alt="Image of a Noizebra output.">
<img src="/noizebra-15.png" alt="Image of a Noizebra output.">
<img src="/noizebra-16.png" alt="Image of a Noizebra output.">
<img src="/noizebra-17.png" alt="Image of a Noizebra output.">
<img src="/noizebra-18.png" alt="Image of a Noizebra output.">
<img src="/noizebra-19.png" alt="Image of a Noizebra output.">
<img src="/noizebra-20.png" alt="Image of a Noizebra output."></p>
]]></description>
      
        <media:thumbnail url="http://localhost:1313/noizebra-00.png" />
      
    </item>
    
    
    
    <item>
      <title>IPSYS - Particle system with nice random laws in C &amp; OpenGL</title>
      <link>http://localhost:1313/posts/ipsys/</link>
      <pubDate>Wed, 06 Mar 2024 18:51:08 +0100</pubDate>
      
      <guid>http://localhost:1313/posts/ipsys/</guid>
      <description><![CDATA[<p>Visualizer of a particle system with randomized interaction laws that often happen to be quite mesmerizing to contemplate. Fast, colorful and somewhat intresting.</p>
<p><a href="https://github.com/anima-libera/ipsys">GitHub repository</a></p>
<h1 id="features">Features</h1>
<ul>
<li>Particle system that runs on the GPU in a compute shader.</li>
<li>Different particle types, the number of which is decided at launch time.</li>
<li>Interaction laws for each oriented pair of particle types:
<ul>
<li>The interaction laws depend on the distance between the interactee and the interacter particles.</li>
<li>There are multiple laws for each oridented pair:
<ul>
<li>A law that dictates attraction/repultion,</li>
<li>a law that dictates rotation to the left/right, and</li>
<li>a law that dictates acceleration/deceleration.</li>
</ul>
</li>
</ul>
</li>
<li>Interaction law randomizer, carefully tweaked to maximize &ldquo;intresting&rdquo; results occurences.</li>
<li>Randomized colors for each partcile type, color changing with speed and pressure (number of overlaping other particles).</li>
<li>Fading effect that leaves a tail behind particles</li>
<li>Saving/loading to/from disk laws, colors and state, written in a custom file format.</li>
<li>Grounds for a widget tree that is actually be maintainable in C.</li>
</ul>
<h1 id="a-few-gifs">A few gifs</h1>
<p><img src="/ipsys-01.gif" alt="Gif of an Ipsys system.">
<img src="/ipsys-37.gif" alt="Gif of an Ipsys system.">
<img src="/ipsys-38.gif" alt="Gif of an Ipsys system.">
<img src="/ipsys-39.gif" alt="Gif of an Ipsys system."></p>
<h1 id="gallery">Gallery</h1>
<p><img src="/ipsys-saves-01.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-02.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-03.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-04.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-05.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-06.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-07.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-08.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-09.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-10.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-11.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-12.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-13.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-14.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-15.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-16.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-17.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-18.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-19.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-20.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-21.png" alt="Image of an Ipsys system.">
<img src="/ipsys-saves-22.png" alt="Image of an Ipsys system."></p>
<p><img src="/ipsys-00.png" alt="Image of an Ipsys system.">
<img src="/ipsys-02.png" alt="Image of an Ipsys system.">
<img src="/ipsys-03.png" alt="Image of an Ipsys system.">
<img src="/ipsys-04.png" alt="Image of an Ipsys system.">
<img src="/ipsys-05.png" alt="Image of an Ipsys system.">
<img src="/ipsys-06.png" alt="Image of an Ipsys system.">
<img src="/ipsys-07.png" alt="Image of an Ipsys system.">
<img src="/ipsys-08.png" alt="Image of an Ipsys system.">
<img src="/ipsys-09.png" alt="Image of an Ipsys system.">
<img src="/ipsys-10.png" alt="Image of an Ipsys system.">
<img src="/ipsys-11.png" alt="Image of an Ipsys system.">
<img src="/ipsys-12.png" alt="Image of an Ipsys system.">
<img src="/ipsys-13.png" alt="Image of an Ipsys system.">
<img src="/ipsys-14.png" alt="Image of an Ipsys system.">
<img src="/ipsys-15.png" alt="Image of an Ipsys system.">
<img src="/ipsys-16.png" alt="Image of an Ipsys system.">
<img src="/ipsys-17.png" alt="Image of an Ipsys system.">
<img src="/ipsys-18.png" alt="Image of an Ipsys system.">
<img src="/ipsys-19.png" alt="Image of an Ipsys system.">
<img src="/ipsys-20.png" alt="Image of an Ipsys system.">
<img src="/ipsys-21.png" alt="Image of an Ipsys system.">
<img src="/ipsys-22.png" alt="Image of an Ipsys system.">
<img src="/ipsys-23.png" alt="Image of an Ipsys system.">
<img src="/ipsys-24.png" alt="Image of an Ipsys system.">
<img src="/ipsys-25.png" alt="Image of an Ipsys system.">
<img src="/ipsys-26.png" alt="Image of an Ipsys system.">
<img src="/ipsys-27.png" alt="Image of an Ipsys system.">
<img src="/ipsys-28.png" alt="Image of an Ipsys system.">
<img src="/ipsys-29.png" alt="Image of an Ipsys system.">
<img src="/ipsys-30.png" alt="Image of an Ipsys system.">
<img src="/ipsys-31.png" alt="Image of an Ipsys system.">
<img src="/ipsys-32.png" alt="Image of an Ipsys system.">
<img src="/ipsys-33.png" alt="Image of an Ipsys system.">
<img src="/ipsys-34.png" alt="Image of an Ipsys system.">
<img src="/ipsys-35.png" alt="Image of an Ipsys system.">
<img src="/ipsys-36.png" alt="Image of an Ipsys system."></p>
]]></description>
      
        <media:thumbnail url="http://localhost:1313/ipsys-saves-21.png" />
      
    </item>
    
    
    
    <item>
      <title>Custom Build System for C/C&#43;&#43; in Python</title>
      <link>http://localhost:1313/posts/buildsystem/</link>
      <pubDate>Wed, 06 Mar 2024 18:50:08 +0100</pubDate>
      
      <guid>http://localhost:1313/posts/buildsystem/</guid>
      <description><![CDATA[<p>Handmade build system for C/C++ executable projects, made in Python.</p>
<h1 id="features">Features</h1>
<ul>
<li>Creating new source files warrant no modification of the build system.</li>
<li>Incremental compilation, keeps artifacts and recompile only the translation units that have changed.</li>
<li>Parses source files for <code>#include</code>s to make an inclusion graph and propagate changes in headers down the graph to flag all concerned translation units for recompilation correctly.</li>
<li>The inclusion graph can be converted to a DOT file.</li>
<li>Allows a special header to contain special custom declarations that trigger code generation to embed text/binary ressources in the binary.</li>
<li>Allows to run the compiled binary after compilation, but only if compilation worked.</li>
<li>Different compilation options produce artifacts that are stored separately so as to reproduce compilation profiles.</li>
<li>Easy to tweak to the needs of the project, that was the whole point of making a custom build system.</li>
</ul>
<h1 id="why-why-not-just-use-cmake-or-make">Why? Why not just use CMake or Make?</h1>
<p>The standard for C and C++ projects is to use CMake, or sometimes just Make. Some benefits are to be gained from such decision, for example some features such as parallel compilation, or the fact that some libraries include a bit of CMake script that is meant to ease its use as a dependency in CMake projects.</p>
<p>In my humble opinion, these benefits do not outweight the inconvenience of how hard it is to understand the obscure ways by which these build systems are indended to be used and configured. If it is quite easy to get them to work on a project by copy-pasting the words of power from StackOverflow into our project, it often remains too mysterious (at least for me) to troubleshoot issues or tweak.</p>
<p>In the end, the build system for a project is just a program that handles the efficient management of the compiling process. I understand that some domain specific language can make the writing and maintenance of such program easier by providing language features related to file and compilation handling. I do not think that being a domain specific language is an excuse to be so uncomfortable and hard to use as the DSLs of CMake and Make. Using a more classic general purpose programming language such as Python is so much nicer, with the small price of having to reimplement some features by hand.</p>
<p>The build system is an important detail of a C/C++ project; a detail, but an important one. I felt more confident in the future of these projects knowing that I fully understood the build system and could tweak/augment/fix it to make it fit to the needs of the project. Using a proper language also allows to augment the build system with features such as code generation, that I believe even a master of CMake script would have a hard time to implement in such an impractical language.</p>
<p><em>Note</em>: This custom build system was used on personal hobby projects, where I thought it made sense. In a team of enough people, the fact that some solution is an industry standard makes it more relevant due to being known (to some extent) by all the team. I may find it intresting to design a custom writing system if there were no other humans to read it, but since there are other humans to communicate with then the standard writing system shared by everyone has more value.</p>
<h1 id="where-is-it-used">Where is it used?</h1>
<p>There is no standalone version of this build system, it was copy-pasted in new projects and tweaked accordingly.</p>
<ul>
<li><a href="https://github.com/anima-libera/qwy2/tree/6be3c50bba2e2fcde6e47e67a4b8273bd836b2ce/buildsystem">Here</a> it is used in <a href="http://localhost:1313/posts/qwy2/">Qwy2</a> (C++ project), one can see the use of code generation triggered by the special declarations in <a href="https://github.com/anima-libera/qwy2/blob/6be3c50bba2e2fcde6e47e67a4b8273bd836b2ce/src/embedded.hpp">this special header</a> to embed some ressources in the binary.</li>
</ul>
<p>The other projects it was used in did not make it to this portfolio due to not being presentable enough due to being abandoned too soon.</p>
<ul>
<li><a href="https://github.com/anima-libera/WhyCrystals-abandoned-2/tree/13c518f35dc117efe8e8cde31050be757cac7a6a/buildsystem">Here</a> it is used in an abandoned C project that I happened to have posted on GitHub, with the code generation for ressource embedding being triggered by <a href="https://github.com/anima-libera/WhyCrystals-abandoned-2/blob/13c518f35dc117efe8e8cde31050be757cac7a6a/src/embedded.h">this special header</a>.</li>
</ul>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Push Dungeon - Roguelike with sokoban-like mechanics in Rust</title>
      <link>http://localhost:1313/posts/pushdg/</link>
      <pubDate>Wed, 06 Mar 2024 18:49:08 +0100</pubDate>
      
      <guid>http://localhost:1313/posts/pushdg/</guid>
      <description><![CDATA[<p>Dungeon crawler on a procedurally generated square-tiled grid with turn-based sokoban-like mechanics. Instead of winning by grinding and having high enough stats, what if we fight by carefully controlling the layout like we win in a sokoban-like puzzle game? Push and pull objects on the grid, anticipate or even bait the enemies in a position in which you win, avoid getting cornered or blocked as the &ldquo;redo&quot;s (points spent to cancel actions) are limited and as precious as HP, if not more. Death can be undone if there are enough reods left to get back in a non-losing position.</p>
<p><a href="https://github.com/anima-libera/pushdg">GitHub repository</a></p>
<h1 id="the-idea">The idea</h1>
<p>Instead of having objects in an inventory and being decribed by a wall of stat numbers, here the objects are on the grid and must be pushed or pulled around in a sokoban-like fashion and the stats are replaced by the unique properties of objects.</p>
<p>Agents (the player, the enemies, anything that moves on its own) has a force (for now, 2) that allows them to push at most a equal mass in one move. A rock has a mass of 1 (like most objects), so the player may push at most 2 rocks in one move. The walls are too heavy to be pushed. The enemies and the player are also too heavy to be pushed, so instead of pushing eachother around they must hit each other to lower the other&rsquo;s HP to 0. When pushing fails, objects in the attempted push chain try to interact with what they were pushed against and this may result in a hit if a target has HP and can take damages.</p>
<p>Carefully organizing the layout of a battle to put the enemy in a losing position is the way to go in Push Dungeon. Taking a few hits is fine (there are regen hearts to find), making a few mistakes is fine (it may cost redos, but there are also redo hearts to find), but making too many miskates without enough redos may lead to an unescapable position, which is how a puzzle game with limited redos is lost.</p>
<h1 id="features">Features</h1>
<ul>
<li>Procedural generation of messy dungeon-like maps which often happen to be intresting to play in.</li>
<li>Multiple objects with different mechanics (key to open doors, vision-blocking walls and pushable bush, see-through gem, shield that deals no damages, sword that deals more damages, pickaxe to break walls, rope that is pullable and can pull an other object, etc.).</li>
<li>Simple animations when objects move or are moved, damage number simple animations.</li>
<li>Enemies with a simple move heuristic which already provide intresting challenges when in great numbers and depending on the layout.</li>
</ul>
<h1 id="gallery">Gallery</h1>
<p><img src="/pushdg-01.png" alt="Image of some Push Dungeon game.">
<img src="/pushdg-02.png" alt="Image of some Push Dungeon game.">
<img src="/pushdg-04.png" alt="Image of some Push Dungeon game.">
<img src="/pushdg-05.png" alt="Image of some Push Dungeon game."></p>
]]></description>
      
        <media:thumbnail url="http://localhost:1313/pushdg-03.png" />
      
    </item>
    
    
    
    <item>
      <title>SFLK - Interpreted programming language implemented in Rust</title>
      <link>http://localhost:1313/posts/sflk/</link>
      <pubDate>Wed, 06 Mar 2024 18:48:08 +0100</pubDate>
      
      <guid>http://localhost:1313/posts/sflk/</guid>
      <description><![CDATA[<p>Trying their hand at &ldquo;making their own programming language&rdquo; is common place among programmers. My attempt at an interpreted language aimed at trying new things instead of focussing on speed, having fun instead of believing that my language would attract any intrest, there are hundreds of new languages each months after all.</p>
<p><a href="https://github.com/sflk-lang/sflk">GitHub repository</a></p>
<h1 id="features">Features</h1>
<ul>
<li>Handmade tokenizer and parser.</li>
<li>Handmade implementation of <a href="https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic">big integers and arbitrarily precise fractions</a> (!!), with unit tests. Can be seen <a href="https://github.com/sflk-lang/sflk/blob/849f8b1571475e25f14017ff61d7d65bfd6fc40f/sflk-lang/src/bignums.rs">here</a>.</li>
<li>Algebraic effects, which I only learned about after implementng them (they are called &ldquo;signals&rdquo; in SFLK). All side effects executed by a scope can be intercepted by an outer scope with full control about what to do with it and how to respond.</li>
<li>Bytecode.</li>
<li>Visualizer of the AST and of the program execution (with scopes visible as gutter indentations).</li>
<li>Grounds for the pretty printing of remarks about the program.</li>
<li>Original design in some syntactical and semantical aspects of the language (most of which are for fun, to try something new regardless of usefulness or relevancy):
<ul>
<li>No statement separator, ignored whitespace and two-letters keywords make for concise scripts.</li>
<li>Arbitrary number and order of &ldquo;then&rdquo; and &ldquo;else&rdquo; branches of if statements, same goes for some other clauses of other statements such as loop body and such.</li>
<li>Loop separator clause that runs inbetween iterations of the loop body.</li>
<li>Blocks of code are expressions, first-class values that can be executed in the current scope or in a sub-scope, they can be concatenated together or repeated, they replace functions.</li>
<li>Variable table of a scope can be copied, manipulated and poored in a scope, they replace hashmaps with identifier strings as keys.</li>
<li>Method-chain-like precedence for expressions involving binary operators.</li>
<li>Syntax error that disturb even the parser are &ldquo;ignored&rdquo; in that they are ebedded in the AST and as long as they are not executed then no error is raised. Debugging tools in the intrepreted allow to still see these errors as it would be hard to debug otherwise.</li>
</ul>
</li>
<li>A README explaning all the language quirks and features.</li>
</ul>
<h1 id="why">Why?</h1>
<p>For fun!</p>
<h1 id="gallery">Gallery</h1>
<p>Here can be seen the pretty printed AST of an SFLK program, and the pretty printing of its execution with scope visualization:</p>
<p><img src="/sflk-01.png" alt="Image of an SFLK program AST and detailed execution."></p>
<p>Here can be seen an SFLK program containing a loop statement that has a separaror clause (<code>sp</code> keyword followed by a statement) which makes it trivial to print a separation between the prints of each iteration:</p>
<p><img src="/sflk-02.png" alt="Image of an SFLK loop with a separator statement."></p>
<p>Here can be seed an SFLK program working with big integers, and then an SFLK program working with arbitrarily precise fractions:</p>
<p><img src="/sflk-03.png" alt="Image of an SFLK program working with big integers.">
<img src="/sflk-04.png" alt="Image of an SFLK program working with arbitrarily precise fractions."></p>
<p>Here can be seen tests of a pretty-printer of remarks on the program:</p>
<p><img src="/sflk-05.png" alt="Image of an SFLK program selected intervals being pretty-printed with notes.">
<img src="/sflk-06.png" alt="Image of an SFLK program selected intervals being pretty-printed with notes.">
<img src="/sflk-07.png" alt="Image of an SFLK program selected intervals being pretty-printed with notes."></p>
<p>Here can be seen an SFLK program outputing an image in <a href="https://en.wikipedia.org/wiki/Netpbm#File_formats">PPM format</a>:</p>
<p><img src="/sflk-08.png" alt="Image of an SFLK program outputing an image.">
<img src="/sflk-09.png" alt="Image of an SFLK program output read as the PPM image it is."></p>
<p>Here can be seen an SFLK program defining and then using a &ldquo;signal interceptor&rdquo; (which happens to really be just an effect handler actually):</p>
<p><img src="/sflk-10.png" alt="Image of an SFLK program defining a &ldquo;signal interceptor&rdquo; (an effect handler).">
<img src="/sflk-11.png" alt="Image of an SFLK program using that interceptor."></p>
]]></description>
      
        <media:thumbnail url="http://localhost:1313/sflk-00.png" />
      
    </item>
    
    
    
    <item>
      <title>Spine - Compiled stack-based language implemented in C then Rust</title>
      <link>http://localhost:1313/posts/spine/</link>
      <pubDate>Wed, 06 Mar 2024 18:47:08 +0100</pubDate>
      
      <guid>http://localhost:1313/posts/spine/</guid>
      <description><![CDATA[<p>Compiler of a stack-based simple language down to ELF executable with x86_64 machine code generated by handwritten code (no assembly), which works! First started in C, then a rewrite in Rust was started with better abstractions.</p>
<p><a href="https://github.com/anima-libera/spine-lang">GitHub repository of the C version</a>
<a href="https://github.com/anima-libera/spine">GitHub repository of the Rust attempt</a></p>
<h1 id="features">Features</h1>
<ul>
<li>Generates working ELF executables with generated x86_64 machine code.
<ul>
<li>ELF headers generator.</li>
<li>Machine code generator for some x86_64 instructions, no assembly.</li>
<li>Data segment, code segment, labels with offsets corrected during final ELF generation.</li>
</ul>
</li>
<li>Simple stack-based language, <em>C version only</em> for now:
<ul>
<li>One-character instructions with no whitespace separation required, for <a href="https://en.wikipedia.org/wiki/Code_golf">golfing</a> purposes.</li>
<li>Control flow with ifs, loops, callbacks and named functions.</li>
<li>Classic stack manipulations instructions.</li>
<li>Support of two local valriables (only two for declaration with less characters for golfing) which can be &ldquo;runtime-shadowed&rdquo; or not in each function or callback.</li>
<li>Separated the call stack from the data stack (even though x86_64 only have one stack for both).</li>
<li>Pointer dereferecing read and write operations.</li>
<li>Syscall instruction, which provides lots of freedom.</li>
</ul>
</li>
</ul>
<h1 id="gallery">Gallery</h1>
<p>Here is a Spine program (C implementation) that prints <code>argc</code>, all of <code>argv</code> and then all of <code>envp</code> (the environment variables), all of which is on the stack at the start of program execution on Linux. <code>N</code> is a function that prints an integer in base 10, <code>S</code> prints a Spine string (pointer and length, which are what is pushed by Spine string literals), and <code>Z</code> print null-terminated string (or C strings, which are how <code>argv</code> and <code>envp</code> are provided).</p>
<p><img src="/spine-01.png" alt="Image of a Spine program printing argc, argv and envp."></p>
<p>Here are some Spine named functions. <code>N</code> is different from the version above as it uses the local variables (<code>h</code> and <code>v</code>) to have a shorter code. <code>S</code> uses the fact that the write syscall takes the length of a string to do only one syscall. <code>M</code> allocates memory from the OS via the <code>mmap</code> syscall (one of the intended uses of this syscall).</p>
<p><img src="/spine-02.png" alt="Image of some Spine named functions."></p>
<h1 id="why">Why?</h1>
<p>For fun!</p>
<p>This took some learning about the x86_64 architecture, the <a href="https://cdrdv2-public.intel.com/782156/325383-sdm-vol-2abcd.pdf">x86_64 machine code representation of assembly instructions</a> (which is known to be quite complex in some areas), the 64-bit <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF executable format</a> with its many fields and headers, how to work with machine code (not even assembly) and debug such matters.</p>
]]></description>
      
        <media:thumbnail url="http://localhost:1313/spine-02.png" />
      
    </item>
    
    
  </channel>
</rss>
